## Quick Sort 快排
### 基本原理
用到了递归方法。
第一轮：把0索引的书作为基准数，确定基准数在数组中正确的位置。  
比基准数小的全部在左边，比基准数大的全部在右边。  
（例如：基准数是6，start就要找比6大的数，在这个地方停下来，end就要找比6小数，在这里停下来，交换这两数；交换完，就start接着找比6大的，end接着找比6小的，在交换，当start和end在同一index的时候，这就是基准数应该存在的位置）

注意：一定要先移动end，在移动start，因为先移动end就可以保证基准数归位的时候，是一个比基准数小的数交换位置。
## recursion 递归
把一个复杂问题层层转化成与圆问题相似的规模较小的问题来解决，解决问题时自己调用自己的方法，一般分为两种情况，递归情况（recursion case）和基本情况（base case）。
例如：  
阶乘计算：
基本情况：0! = 1  
递归情况：n! = n * (n-1)!  

斐波那契数列：
基本情况：fib(0) = 0, fib(1) = 1  
递归情况：fib(n) = fib(n-1) + fib(n-2)  

### summary
递归一定要写出口。

## summary of sort
- bubble sort: 相邻元素两两比较，小的在前面，大的在后面
- insertion sort: 从0索引开始，那这每一个索引上的元素和后面的元素对吧，小的放前面，大的在后面
- selection sort: 将数组分为有序和无序两组，遍历无序数组，将元素插入有序序列即可
- quick sort: 将排序范围中的第一个数作为基准数，在定义两个变量start和end；start从前往后找比基准数大的，end从后往前找比基准数小的。找到之后，交换start和end对应元素，并循环这一过程，直到start和end处于同一index，该位置就是基准数在数组中应存入的位置，再让基准数和这个数交换。
